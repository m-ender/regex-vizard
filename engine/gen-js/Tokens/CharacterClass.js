// Generated by CoffeeScript 1.4.0
(function() {
  var root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.CharacterClass = (function(_super) {

    __extends(CharacterClass, _super);

    function CharacterClass(debug, negated, elements) {
      this.negated = negated != null ? negated : false;
      this.elements = elements != null ? elements : [];
      CharacterClass.__super__.constructor.call(this, debug);
    }

    CharacterClass.prototype.reset = function() {
      CharacterClass.__super__.reset.call(this);
      return this.attempted = false;
    };

    CharacterClass.prototype.addCharacter = function(character) {
      return this.elements.push(character);
    };

    CharacterClass.prototype.addRange = function(startCharacter, endCharacter) {
      return this.elements.push({
        start: startCharacter.charCodeAt(0),
        end: endCharacter.charCodeAt(0)
      });
    };

    CharacterClass.prototype.nextMatch = function(state, report) {
      var char;
      if (this.attempted) {
        this.reset();
        return false;
      }
      char = state.input[state.currentPosition];
      if (this.isInClass(char)) {
        this.attempted = true;
        return state.currentPosition + 1;
      }
      return false;
    };

    CharacterClass.prototype.isInClass = function(char) {
      var element, inSet, _i, _len, _ref, _ref1;
      if (char === StartGuard || char === EndGuard) {
        return false;
      }
      inSet = false;
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        if (typeof element === "string" && char === element || element instanceof CharacterClass && element.isInClass(char) || (element.start <= (_ref1 = char.charCodeAt(0)) && _ref1 <= element.end)) {
          inSet = true;
          break;
        }
      }
      return inSet !== this.negated;
    };

    return CharacterClass;

  })(root.Token);

  root.DigitClass = (function(_super) {

    __extends(DigitClass, _super);

    function DigitClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      DigitClass.__super__.constructor.call(this, debug, negated, [
        {
          start: "0".charCodeAt(0),
          end: "9".charCodeAt(0)
        }
      ]);
    }

    return DigitClass;

  })(root.CharacterClass);

  root.WordClass = (function(_super) {

    __extends(WordClass, _super);

    function WordClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WordClass.__super__.constructor.call(this, debug, negated, [
        {
          start: "A".charCodeAt(0),
          end: "Z".charCodeAt(0)
        }, {
          start: "a".charCodeAt(0),
          end: "z".charCodeAt(0)
        }, {
          start: "0".charCodeAt(0),
          end: "9".charCodeAt(0)
        }, "_"
      ]);
    }

    return WordClass;

  })(root.CharacterClass);

  root.WhitespaceClass = (function(_super) {

    __extends(WhitespaceClass, _super);

    function WhitespaceClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WhitespaceClass.__super__.constructor.call(this, debug, negated, [
        {
          start: 0x9,
          end: 0xd
        }, "\u0020", "\u00a0", "\u1680", "\u180e", {
          start: 0x2000,
          end: 0x200a
        }, "\u2028", "\u2029", "\u202f", "\u205f", "\u3000", "\ufeff"
      ]);
    }

    return WhitespaceClass;

  })(root.CharacterClass);

  root.Wildcard = (function(_super) {

    __extends(Wildcard, _super);

    function Wildcard(debug) {
      Wildcard.__super__.constructor.call(this, debug);
    }

    Wildcard.prototype.reset = function() {
      Wildcard.__super__.reset.call(this);
      return this.attempted = false;
    };

    Wildcard.prototype.nextMatch = function(state, report) {
      var _ref;
      if (this.attempted) {
        this.reset();
        return false;
      }
      if ((_ref = state.input[state.currentPosition]) !== "\n" && _ref !== "\r" && _ref !== "\u2028" && _ref !== "\u2029" && _ref !== EndGuard) {
        this.attempted = true;
        return state.currentPosition + 1;
      }
      return false;
    };

    return Wildcard;

  })(root.Token);

}).call(this);
