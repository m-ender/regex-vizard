// Generated by CoffeeScript 1.4.0
(function() {
  var root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Quantifier = (function(_super) {

    __extends(Quantifier, _super);

    function Quantifier(debug, token, min, max) {
      this.min = min;
      this.max = max;
      Quantifier.__super__.constructor.call(this, debug, token);
      this.minGroup = -1;
      this.nGroups = 0;
      this.clearer = [];
    }

    Quantifier.prototype.reset = function(state) {
      Quantifier.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].freshSubStates = this.collectSubStates(state, this.subtokens[0]);
      state.tokens[this.debug.id].instances = [Helper.clone(state.tokens[this.debug.id].freshSubStates)];
      state.tokens[this.debug.id].pos = [];
      state.tokens[this.debug.id].result = false;
      return state.tokens[this.debug.id].captureStack = [];
    };

    Quantifier.prototype.setupStateObject = function(state) {
      var stateObject;
      stateObject = {
        freshSubStates: this.collectSubStates(state, this.subtokens[0]),
        instances: [],
        pos: [],
        result: false,
        captureStack: []
      };
      stateObject.instances.push(Helper.clone(stateObject.freshSubStates));
      return stateObject;
    };

    Quantifier.prototype.collectSubStates = function(state, token) {
      var key, states, subtoken, val, _i, _len, _ref, _ref1;
      states = [];
      key = token.debug.id;
      states[key] = state.tokens[key];
      _ref = token.subtokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        _ref1 = this.collectSubStates(state, subtoken);
        for (key in _ref1) {
          val = _ref1[key];
          states[key] = val;
        }
      }
      return states;
    };

    Quantifier.prototype.restoreSubStates = function(state, subStates) {
      var key, val, _results;
      _results = [];
      for (key in subStates) {
        val = subStates[key];
        _results.push(state.tokens[key] = val);
      }
      return _results;
    };

    Quantifier.prototype.setGroupRange = function(minGroup, nGroups) {
      var i, _i, _ref, _results;
      this.minGroup = minGroup;
      this.nGroups = nGroups;
      _results = [];
      for (i = _i = 0, _ref = this.nGroups; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.clearer[i] = void 0);
      }
      return _results;
    };

    Quantifier.prototype.nextMatch = function(state) {
      var result, token, tokenState, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.result) {
        result = tokenState.result;
        tokenState.result = false;
        if (tokenState.instances.length >= this.min) {
          return result;
        } else {
          return 0;
        }
      }
      if (tokenState.instances.length === 0) {
        this.reset(state);
        return false;
      }
      if (tokenState.instances.length > this.max) {
        tokenState.instances.pop();
        result = state.currentPosition;
        if (tokenState.pos.length > 0) {
          state.currentPosition = tokenState.pos.pop();
        }
        if (tokenState.captureStack.length > 0) {
          [].splice.apply(state.captures, [(_ref = this.minGroup), (this.minGroup + this.nGroups) - _ref].concat(_ref1 = tokenState.captureStack.pop())), _ref1;
        }
        return result;
      }
      token = this.subtokens[0];
      this.restoreSubStates(state, tokenState.instances.pop());
      result = token.nextMatch(state);
      switch (result) {
        case 0:
        case -1:
          tokenState.instances.push(this.collectSubStates(state, token));
          return result;
        case false:
          tokenState.result = state.currentPosition;
          if (tokenState.pos.length > 0) {
            state.currentPosition = tokenState.pos.pop();
          }
          if (tokenState.captureStack.length > 0) {
            [].splice.apply(state.captures, [(_ref2 = this.minGroup), (this.minGroup + this.nGroups) - _ref2].concat(_ref3 = tokenState.captureStack.pop())), _ref3;
          }
          return 0;
        default:
          tokenState.instances.push(this.collectSubStates(state, token));
          if (result === state.currentPosition && tokenState.instances.length > this.min) {
            return this.nextMatch(state);
          }
          tokenState.captureStack.push(state.captures.slice(this.minGroup, this.minGroup + this.nGroups));
          [].splice.apply(state.captures, [(_ref4 = this.minGroup), (this.minGroup + this.nGroups) - _ref4].concat(_ref5 = this.clearer)), _ref5;
          tokenState.instances.push(Helper.clone(tokenState.freshSubStates));
          tokenState.pos.push(state.currentPosition);
          state.currentPosition = result;
          return -1;
      }
    };

    return Quantifier;

  })(root.Token);

  root.Option = (function(_super) {

    __extends(Option, _super);

    function Option(debug, token) {
      Option.__super__.constructor.call(this, debug, token, 0, 1);
    }

    return Option;

  })(root.Quantifier);

  root.RepeatZeroOrMore = (function(_super) {

    __extends(RepeatZeroOrMore, _super);

    function RepeatZeroOrMore(debug, token) {
      RepeatZeroOrMore.__super__.constructor.call(this, debug, token, 0, Infinity);
    }

    return RepeatZeroOrMore;

  })(root.Quantifier);

  root.RepeatOneOrMore = (function(_super) {

    __extends(RepeatOneOrMore, _super);

    function RepeatOneOrMore(debug, token) {
      RepeatOneOrMore.__super__.constructor.call(this, debug, token, 1, Infinity);
    }

    return RepeatOneOrMore;

  })(root.Quantifier);

}).call(this);
