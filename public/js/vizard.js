// Generated by CoffeeScript 1.4.0
(function() {
  var root,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Helper = (function() {

    function Helper() {}

    Helper.clone = function(obj) {
      var key, newInstance;
      if (!(obj != null) || typeof obj !== 'object') {
        return obj;
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = this.clone(obj[key]);
      }
      return newInstance;
    };

    Helper.extend = function() {
      var key, object, sources, target, val, _i, _len;
      target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        object = sources[_i];
        for (key in object) {
          val = object[key];
          target[key] = val;
        }
      }
      return target;
    };

    return Helper;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.StartGuard = -1;

  root.EndGuard = 1;

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Indeterminate = "indeterminate";

  root.Failure = "failure";

  root.Success = "success";

  root.Result = (function() {

    function Result(type, nextPosition) {
      this.type = type;
      this.nextPosition = nextPosition != null ? nextPosition : null;
    }

    Result.failureInstance = new Result(Failure);

    Result.Failure = function() {
      return this.failureInstance;
    };

    Result.indeterminateInstance = new Result(Indeterminate);

    Result.Indeterminate = function() {
      return this.indeterminateInstance;
    };

    Result.Success = function(nextPosition) {
      return new Result(Success, nextPosition);
    };

    return Result;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Inactive = "inactive";

  root.Active = "active";

  root.Matched = "matched";

  root.Failed = "failed";

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Token = (function() {

    function Token(debug, token) {
      this.debug = debug;
      this.subtokens = [];
      if (token && token instanceof Token) {
        this.subtokens.push(token);
      }
    }

    Token.prototype.reset = function(state) {
      var subtoken, _i, _len, _ref, _results;
      _ref = this.subtokens;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        _results.push(subtoken.reset(state));
      }
      return _results;
    };

    Token.prototype.register = function(state) {
      var subtoken, _i, _len, _ref;
      _ref = this.subtokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        subtoken.register(state);
      }
      return state.tokens[this.debug.id] = this.setupStateObject(state);
    };

    Token.prototype.setupStateObject = function() {
      return {};
    };

    Token.prototype.nextMatch = function(state) {
      return false;
    };

    return Token;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.BasicToken = (function(_super) {

    __extends(BasicToken, _super);

    function BasicToken(debug) {
      BasicToken.__super__.constructor.apply(this, arguments);
    }

    BasicToken.prototype.reset = function(state) {
      BasicToken.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].status = Inactive;
      return state.tokens[this.debug.id].attempted = false;
    };

    BasicToken.prototype.setupStateObject = function() {
      return {
        status: Inactive,
        attempted: false
      };
    };

    BasicToken.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        return Result.Failure();
      }
      tokenState.attempted = true;
      result = this.matches(state);
      switch (result.type) {
        case Success:
          tokenState.status = Matched;
          break;
        case Failure:
          tokenState.status = Failed;
      }
      return result;
    };

    return BasicToken;

  })(Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.StartAnchor = (function(_super) {

    __extends(StartAnchor, _super);

    function StartAnchor(debug) {
      StartAnchor.__super__.constructor.apply(this, arguments);
    }

    StartAnchor.prototype.matches = function(state) {
      if (state.input[state.currentPosition - 1] === StartGuard) {
        return Result.Success(state.currentPosition);
      } else {
        return Result.Failure();
      }
    };

    return StartAnchor;

  })(BasicToken);

  root.EndAnchor = (function(_super) {

    __extends(EndAnchor, _super);

    function EndAnchor(debug) {
      EndAnchor.__super__.constructor.apply(this, arguments);
    }

    EndAnchor.prototype.matches = function(state) {
      if (state.input[state.currentPosition] === EndGuard) {
        return Result.Success(state.currentPosition);
      } else {
        return Result.Failure();
      }
    };

    return EndAnchor;

  })(BasicToken);

  root.WordBoundary = (function(_super) {

    __extends(WordBoundary, _super);

    function WordBoundary(debug, negated) {
      this.negated = negated != null ? negated : false;
      WordBoundary.__super__.constructor.call(this, debug);
      this.wordClass = new WordClass();
    }

    WordBoundary.prototype.matches = function(state) {
      var leftChar, rightChar;
      leftChar = state.input[state.currentPosition - 1];
      rightChar = state.input[state.currentPosition];
      if ((this.wordClass.isInClass(leftChar) !== this.wordClass.isInClass(rightChar)) !== this.negated) {
        return Result.Success(state.currentPosition);
      } else {
        return Result.Failure();
      }
    };

    return WordBoundary;

  })(BasicToken);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Character = (function(_super) {

    __extends(Character, _super);

    function Character(debug, character) {
      this.character = character;
      Character.__super__.constructor.call(this, debug);
    }

    Character.prototype.reset = function(state) {
      Character.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].matchedPosition = null;
    };

    Character.prototype.setupStateObject = function() {
      var obj;
      obj = Character.__super__.setupStateObject.apply(this, arguments);
      obj.matchedPosition = null;
      return obj;
    };

    Character.prototype.matches = function(state) {
      if (state.input[state.currentPosition] === this.character) {
        state.tokens[this.debug.id].matchedPosition = state.currentPosition;
        return Result.Success(state.currentPosition + 1);
      } else {
        return Result.Failure();
      }
    };

    return Character;

  })(BasicToken);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.CharacterRange = (function() {

    function CharacterRange(first, last) {
      this.first = this.sanitize(first);
      this.last = this.sanitize(last);
    }

    CharacterRange.prototype.isInRange = function(char) {
      var _ref;
      return (this.first <= (_ref = this.sanitize(char)) && _ref <= this.last);
    };

    CharacterRange.prototype.sanitize = function(char) {
      if (typeof char === "string") {
        return char.charCodeAt(0);
      } else {
        return char;
      }
    };

    return CharacterRange;

  })();

  root.CharacterClass = (function(_super) {

    __extends(CharacterClass, _super);

    function CharacterClass(debug, negated, elements) {
      this.negated = negated != null ? negated : false;
      this.elements = elements != null ? elements : [];
      CharacterClass.__super__.constructor.call(this, debug);
    }

    CharacterClass.prototype.addElement = function(element) {
      return this.elements.push(element);
    };

    CharacterClass.prototype.addRange = function(first, last) {
      return this.elements.push(new CharacterRange(first, last));
    };

    CharacterClass.prototype.matches = function(state) {
      var char;
      char = state.input[state.currentPosition];
      if (this.isInClass(char)) {
        return Result.Success(state.currentPosition + 1);
      } else {
        return Result.Failure();
      }
    };

    CharacterClass.prototype.isInClass = function(char) {
      var element, _i, _len, _ref;
      if (char === StartGuard || char === EndGuard) {
        return false;
      }
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        if (typeof element === "string" && char === element || element instanceof CharacterClass && element.isInClass(char) || element instanceof CharacterRange && element.isInRange(char)) {
          return !this.negated;
        }
      }
      return this.negated;
    };

    return CharacterClass;

  })(BasicToken);

  root.DigitClass = (function(_super) {

    __extends(DigitClass, _super);

    function DigitClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      DigitClass.__super__.constructor.call(this, debug, negated, [new CharacterRange("0", "9")]);
    }

    return DigitClass;

  })(CharacterClass);

  root.WordClass = (function(_super) {

    __extends(WordClass, _super);

    function WordClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WordClass.__super__.constructor.call(this, debug, negated, [new CharacterRange("A", "Z"), new CharacterRange("a", "z"), new CharacterRange("0", "9"), "_"]);
    }

    return WordClass;

  })(CharacterClass);

  root.WhitespaceClass = (function(_super) {

    __extends(WhitespaceClass, _super);

    function WhitespaceClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WhitespaceClass.__super__.constructor.call(this, debug, negated, [new CharacterRange(0x9, 0xd), "\u0020", "\u00a0", "\u1680", "\u180e", new CharacterRange(0x2000, 0x200a), "\u2028", "\u2029", "\u202f", "\u205f", "\u3000", "\ufeff"]);
    }

    return WhitespaceClass;

  })(CharacterClass);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Wildcard = (function(_super) {

    __extends(Wildcard, _super);

    function Wildcard(debug) {
      Wildcard.__super__.constructor.apply(this, arguments);
    }

    Wildcard.prototype.matches = function(state) {
      var _ref;
      if ((_ref = state.input[state.currentPosition]) !== "\n" && _ref !== "\r" && _ref !== "\u2028" && _ref !== "\u2029" && _ref !== EndGuard) {
        return Result.Success(state.currentPosition + 1);
      } else {
        return Result.Failure();
      }
    };

    return Wildcard;

  })(BasicToken);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Disjunction = (function(_super) {

    __extends(Disjunction, _super);

    function Disjunction(debug, token) {
      Disjunction.__super__.constructor.apply(this, arguments);
    }

    Disjunction.prototype.reset = function(state) {
      Disjunction.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].i = 0;
    };

    Disjunction.prototype.setupStateObject = function() {
      return {
        status: Inactive,
        i: 0
      };
    };

    Disjunction.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.i === this.subtokens.length) {
        return Result.Failure();
      }
      result = this.subtokens[tokenState.i].nextMatch(state);
      switch (result.type) {
        case Success:
        case Indeterminate:
          return result;
        case Failure:
          ++tokenState.i;
          return Result.Indeterminate();
      }
    };

    return Disjunction;

  })(Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Group = (function(_super) {

    __extends(Group, _super);

    function Group(debug, token, index) {
      this.index = index;
      Group.__super__.constructor.call(this, debug, token);
    }

    Group.prototype.reset = function(state) {
      Group.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].status = Inactive;
      state.tokens[this.debug.id].result = null;
      return state.tokens[this.debug.id].firstPosition = false;
    };

    Group.prototype.setupStateObject = function() {
      return {
        status: Inactive,
        result: null,
        firstPosition: false
      };
    };

    Group.prototype.register = function(state) {
      state.captures[this.index] = void 0;
      return Group.__super__.register.apply(this, arguments);
    };

    Group.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.result !== null) {
        result = tokenState.result;
        if (result.type === Success) {
          tokenState.result = null;
        }
        return result;
      }
      if (tokenState.firstPosition === false) {
        tokenState.firstPosition = state.currentPosition;
      }
      result = this.subtokens[0].nextMatch(state);
      switch (result.type) {
        case Indeterminate:
          tokenState.status = Active;
          return result;
        case Failure:
          tokenState.status = Failed;
          tokenState.result = result;
          state.captures[this.index] = void 0;
          return Result.Indeterminate();
        case Success:
          if (this.index === 0) {
            state.currentPosition = result.nextPosition;
          }
          tokenState.status = Matched;
          state.captures[this.index] = state.input.slice(tokenState.firstPosition, result.nextPosition).join("");
          tokenState.result = result;
          return Result.Indeterminate();
      }
    };

    return Group;

  })(Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Quantifier = (function(_super) {

    __extends(Quantifier, _super);

    function Quantifier(debug, token, min, max) {
      this.min = min;
      this.max = max;
      Quantifier.__super__.constructor.call(this, debug, token);
      this.minGroup = -1;
      this.nGroups = 0;
      this.clearer = [];
    }

    Quantifier.prototype.reset = function(state) {
      Quantifier.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].freshSubStates = this.collectSubStates(state, this.subtokens[0]);
      state.tokens[this.debug.id].instances = [Helper.clone(state.tokens[this.debug.id].freshSubStates)];
      state.tokens[this.debug.id].pos = [];
      state.tokens[this.debug.id].nextPosition = null;
      return state.tokens[this.debug.id].captureStack = [];
    };

    Quantifier.prototype.setupStateObject = function(state) {
      var stateObject;
      stateObject = {
        status: Inactive,
        freshSubStates: this.collectSubStates(state, this.subtokens[0]),
        instances: [],
        pos: [],
        nextPosition: null,
        captureStack: []
      };
      stateObject.instances.push(Helper.clone(stateObject.freshSubStates));
      return stateObject;
    };

    Quantifier.prototype.collectSubStates = function(state, token) {
      var key, states, subtoken, val, _i, _len, _ref, _ref1;
      states = [];
      key = token.debug.id;
      states[key] = state.tokens[key];
      _ref = token.subtokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        _ref1 = this.collectSubStates(state, subtoken);
        for (key in _ref1) {
          val = _ref1[key];
          states[key] = val;
        }
      }
      return states;
    };

    Quantifier.prototype.restoreSubStates = function(state, subStates) {
      var key, val, _results;
      _results = [];
      for (key in subStates) {
        val = subStates[key];
        _results.push(state.tokens[key] = val);
      }
      return _results;
    };

    Quantifier.prototype.setGroupRange = function(minGroup, nGroups) {
      var i, _i, _ref, _results;
      this.minGroup = minGroup;
      this.nGroups = nGroups;
      _results = [];
      for (i = _i = 0, _ref = this.nGroups; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.clearer[i] = void 0);
      }
      return _results;
    };

    Quantifier.prototype.nextMatch = function(state) {
      var pos, result, token, tokenState, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.nextPosition !== null) {
        pos = tokenState.nextPosition;
        tokenState.nextPosition = null;
        if (tokenState.instances.length >= this.min) {
          return Result.Success(pos);
        } else {
          return Result.Indeterminate();
        }
      }
      if (tokenState.instances.length === 0) {
        return Result.Failure();
      }
      if (tokenState.instances.length > this.max) {
        tokenState.instances.pop();
        pos = state.currentPosition;
        if (tokenState.pos.length > 0) {
          state.currentPosition = tokenState.pos.pop();
        }
        if (tokenState.captureStack.length > 0) {
          [].splice.apply(state.captures, [(_ref = this.minGroup), (this.minGroup + this.nGroups) - _ref].concat(_ref1 = tokenState.captureStack.pop())), _ref1;
        }
        return Result.Success(pos);
      }
      token = this.subtokens[0];
      this.restoreSubStates(state, tokenState.instances.pop());
      result = token.nextMatch(state);
      switch (result.type) {
        case Indeterminate:
          tokenState.instances.push(this.collectSubStates(state, token));
          return result;
        case Failure:
          tokenState.nextPosition = state.currentPosition;
          if (tokenState.pos.length > 0) {
            state.currentPosition = tokenState.pos.pop();
          }
          if (tokenState.captureStack.length > 0) {
            [].splice.apply(state.captures, [(_ref2 = this.minGroup), (this.minGroup + this.nGroups) - _ref2].concat(_ref3 = tokenState.captureStack.pop())), _ref3;
          }
          return Result.Indeterminate();
        case Success:
          tokenState.instances.push(this.collectSubStates(state, token));
          if (result.nextPosition === state.currentPosition && tokenState.instances.length > this.min) {
            return this.nextMatch(state);
          }
          tokenState.captureStack.push(state.captures.slice(this.minGroup, this.minGroup + this.nGroups));
          [].splice.apply(state.captures, [(_ref4 = this.minGroup), (this.minGroup + this.nGroups) - _ref4].concat(_ref5 = this.clearer)), _ref5;
          tokenState.instances.push(Helper.clone(tokenState.freshSubStates));
          tokenState.pos.push(state.currentPosition);
          state.currentPosition = result.nextPosition;
          return Result.Indeterminate();
      }
    };

    return Quantifier;

  })(Token);

  root.Option = (function(_super) {

    __extends(Option, _super);

    function Option(debug, token) {
      Option.__super__.constructor.call(this, debug, token, 0, 1);
    }

    return Option;

  })(root.Quantifier);

  root.RepeatZeroOrMore = (function(_super) {

    __extends(RepeatZeroOrMore, _super);

    function RepeatZeroOrMore(debug, token) {
      RepeatZeroOrMore.__super__.constructor.call(this, debug, token, 0, Infinity);
    }

    return RepeatZeroOrMore;

  })(root.Quantifier);

  root.RepeatOneOrMore = (function(_super) {

    __extends(RepeatOneOrMore, _super);

    function RepeatOneOrMore(debug, token) {
      RepeatOneOrMore.__super__.constructor.call(this, debug, token, 1, Infinity);
    }

    return RepeatOneOrMore;

  })(root.Quantifier);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Sequence = (function(_super) {

    __extends(Sequence, _super);

    function Sequence(debug) {
      Sequence.__super__.constructor.call(this, debug);
    }

    Sequence.prototype.reset = function(state) {
      Sequence.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].i = 0;
      return state.tokens[this.debug.id].pos = [];
    };

    Sequence.prototype.setupStateObject = function() {
      return {
        status: Inactive,
        i: 0,
        pos: []
      };
    };

    Sequence.prototype.nextMatch = function(state) {
      var currentToken, result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.i === -1) {
        return Result.Failure();
      }
      if (this.subtokens.length === 0) {
        tokenState.i = -1;
        return Result.Success(state.currentPosition);
      }
      currentToken = this.subtokens[tokenState.i];
      result = currentToken.nextMatch(state);
      switch (result.type) {
        case Failure:
          --tokenState.i;
          if (tokenState.pos.length > 0) {
            state.currentPosition = tokenState.pos.pop();
          }
          return Result.Indeterminate();
        case Indeterminate:
          return result;
        case Success:
          if (tokenState.i === this.subtokens.length - 1) {
            tokenState.wasFinal = true;
            return result;
          } else {
            tokenState.pos.push(state.currentPosition);
            state.currentPosition = result.nextPosition;
            ++tokenState.i;
            this.subtokens[tokenState.i].reset(state);
            return Result.Indeterminate();
          }
      }
    };

    return Sequence;

  })(Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Parser = (function() {

    function Parser() {}

    Parser.parsePattern = function(string) {
      var char, current, debug, element, fillGroupRanges, group, i, lastCaptureIndex, lastId, nGroups, nestingStack, squash, start, treeRoot, _, _ref, _ref1;
      lastId = -1;
      treeRoot = new Group({
        sourceOpen: '',
        sourceClose: '',
        id: ++lastId
      }, new Disjunction({
        id: ++lastId
      }, new Sequence({
        id: ++lastId
      })), 0);
      nestingStack = [];
      current = treeRoot.subtokens[0];
      i = 0;
      lastCaptureIndex = 0;
      while (i < string.length) {
        char = string.charAt(i);
        switch (char) {
          case "\\":
            start = i;
            _ref = this.parseEscapeSequence(false, string, i + 1), i = _ref[0], element = _ref[1];
            element.debug = {
              source: string.substring(start, i),
              id: ++lastId
            };
            this.append(current, element);
            break;
          case "[":
            i = this.parseCharacterClass(string, current, i + 1, ++lastId);
            break;
          case "^":
            debug = {
              source: char,
              id: ++lastId
            };
            this.append(current, new StartAnchor(debug));
            ++i;
            break;
          case "$":
            debug = {
              source: char,
              id: ++lastId
            };
            this.append(current, new EndAnchor(debug));
            ++i;
            break;
          case ".":
            debug = {
              source: char,
              id: ++lastId
            };
            this.append(current, new Wildcard(debug));
            ++i;
            break;
          case "|":
            current.subtokens.push(new Sequence({
              id: ++lastId
            }));
            ++i;
            break;
          case "(":
            debug = {
              sourceOpen: '(',
              sourceClose: ')',
              id: ++lastId
            };
            group = new Group(debug, new Disjunction({
              id: ++lastId
            }, new Sequence({
              id: ++lastId
            })), ++lastCaptureIndex);
            this.append(current, group);
            nestingStack.push(current);
            current = group.subtokens[0];
            ++i;
            break;
          case ")":
            if (nestingStack.length === 0) {
              throw {
                name: "UnmatchedClosingParenthesisException",
                message: "Unmatched closing parenthesis \")\" at index " + i,
                index: i
              };
            }
            current = nestingStack.pop();
            ++i;
            break;
          case "?":
          case "*":
          case "+":
            i = this.parseQuantifier(current, char, i, ++lastId);
            break;
          default:
            debug = {
              source: char,
              id: ++lastId
            };
            this.append(current, new Character(debug, char));
            ++i;
        }
      }
      if (nestingStack.length !== 0) {
        throw {
          name: "MissingClosingParenthesisException",
          message: "Missing closing parenthesis \")\""
        };
      }
      squash = function(token) {
        var subtoken, _i, _ref1, _results;
        if (token.subtokens.length === 0) {
          return;
        }
        _results = [];
        for (i = _i = 0, _ref1 = token.subtokens.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          subtoken = token.subtokens[i];
          while (((subtoken instanceof Disjunction) || (subtoken instanceof Sequence)) && (subtoken.subtokens.length === 1)) {
            token.subtokens[i] = subtoken.subtokens[0];
            subtoken = token.subtokens[i];
          }
          _results.push(squash(subtoken));
        }
        return _results;
      };
      squash(treeRoot);
      fillGroupRanges = function(token) {
        var max, min, subMax, subMin, subtoken, _i, _len, _ref1, _ref2;
        if (token instanceof Group) {
          min = token.index;
          max = token.index;
        } else {
          min = Infinity;
          max = -Infinity;
        }
        if (token.subtokens.length > 0) {
          _ref1 = token.subtokens;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            subtoken = _ref1[_i];
            _ref2 = fillGroupRanges(subtoken), subMin = _ref2[0], subMax = _ref2[1];
            min = Math.min(min, subMin);
            max = Math.max(max, subMax);
          }
        }
        if (token instanceof Quantifier && min < Infinity && max > -Infinity) {
          token.setGroupRange(min, max - min + 1);
        }
        return [min, max];
      };
      _ref1 = fillGroupRanges(treeRoot), _ = _ref1[0], nGroups = _ref1[1];
      return [treeRoot, nGroups];
    };

    Parser.parseCharacterClass = function(string, current, i, id) {
      var char, debug, element, elements, endC, lastElement, negated, newI, nextElement, start, startC, _ref, _ref1;
      if (i < string.length && string.charAt(i) === "^") {
        negated = true;
        ++i;
      } else {
        negated = false;
      }
      elements = [];
      start = i;
      while (i < string.length) {
        char = string.charAt(i);
        switch (char) {
          case "]":
            debug = {
              sourceOpen: negated ? '[^' : '[',
              sourceClose: string.substring(start, i),
              sourceCloseLength: ']',
              id: id
            };
            this.append(current, new CharacterClass(debug, negated, elements));
            return i + 1;
          case "\\":
            _ref = this.parseEscapeSequence(true, string, i + 1), i = _ref[0], element = _ref[1];
            elements.push(element);
            break;
          case "-":
            lastElement = elements[elements.length - 1];
            if (lastElement instanceof CharacterClass) {
              throw {
                name: "CharacterClassInRangeException",
                message: "Built-in character classes cannot be used in ranges"
              };
            }
            if (typeof lastElement === "string" && i + 1 < string.length && (nextElement = string.charAt(i + 1)) !== "]") {
              newI = i + 2;
              if (nextElement === "\\") {
                _ref1 = this.parseEscapeSequence(true, string, i + 2), newI = _ref1[0], nextElement = _ref1[1];
              }
              if (nextElement instanceof CharacterClass) {
                throw {
                  name: "CharacterClassInRangeException",
                  message: "Built-in character classes cannot be used in ranges"
                };
              }
              startC = lastElement.charCodeAt(0);
              endC = nextElement.charCodeAt(0);
              if (startC > endC) {
                throw {
                  name: "CharacterClassRangeOutOfOrderException",
                  message: "The character class \"" + lastElement + "\" to \"" + nextElement + "\" is out of order."
                };
              }
              elements.pop();
              elements.push(new CharacterRange(startC, endC));
              i = newI;
            } else {
              elements.push(char);
              ++i;
            }
            break;
          default:
            elements.push(char);
            ++i;
        }
      }
      throw {
        name: "UnterminatedCharacterClassException",
        message: "Missing closing bracket \"]\"",
        index: i
      };
    };

    Parser.parseEscapeSequence = function(inCharacterClass, string, i) {
      var char, element, negated;
      if (i === string.length) {
        throw {
          name: "NothingToEscapeException",
          message: "There is nothing to escape. Most likely, the pattern ends in a backslash \"\\\"",
          index: i - 1
        };
      }
      char = string.charAt(i);
      switch (char) {
        case "0":
          element = "\0";
          break;
        case "f":
          element = "\f";
          break;
        case "n":
          element = "\n";
          break;
        case "r":
          element = "\r";
          break;
        case "t":
          element = "\t";
          break;
        case "v":
          element = "\v";
          break;
        case "d":
        case "D":
          negated = char === "D";
          element = new DigitClass(null, negated);
          break;
        case "w":
        case "W":
          negated = char === "W";
          element = new WordClass(null, negated);
          break;
        case "s":
        case "S":
          negated = char === "S";
          element = new WhitespaceClass(null, negated);
          break;
        case "b":
          element = inCharacterClass ? "\b" : new WordBoundary(null, false);
          break;
        case "B":
          element = inCharacterClass ? "B" : new WordBoundary(null, true);
          break;
        default:
          element = char;
      }
      if (typeof element === "string" && !inCharacterClass) {
        element = new Character(null, element);
      }
      return [i + 1, element];
    };

    Parser.parseQuantifier = function(current, char, i, id) {
      var debug, quantifierClass, st, target;
      st = current.subtokens;
      if (st[st.length - 1].subtokens.length === 0) {
        throw {
          name: "NothingToRepeatException",
          message: "The is nothing to repeat for quantifier \"" + char + "\" at index " + i,
          index: i
        };
      }
      target = this.remove(current);
      if (!((target instanceof Group) || (target instanceof Character) || (target instanceof Wildcard) || (target instanceof CharacterClass))) {
        throw {
          name: "NothingToRepeatException",
          message: "The is nothing to repeat for quantifier \"" + char + "\" at index " + i + ". Only groups, characters and wildcard may be quantified.",
          index: i
        };
      }
      debug = {
        source: char,
        id: id
      };
      quantifierClass = {
        "*": RepeatZeroOrMore,
        "+": RepeatOneOrMore,
        "?": Option
      };
      this.append(current, new quantifierClass[char](debug, target));
      return i + 1;
    };

    Parser.append = function(current, token) {
      var st;
      st = current.subtokens;
      return st[st.length - 1].subtokens.push(token);
    };

    Parser.remove = function(current) {
      var st;
      st = current.subtokens;
      return st[st.length - 1].subtokens.pop();
    };

    return Parser;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Matcher = (function() {

    function Matcher(regex, nGroups, subject) {
      this.regex = regex;
      this.subject = subject;
      this.success = false;
      this.state = Matcher.setupInitialState(this.subject);
      this.regex.register(this.state);
    }

    Matcher.setupInitialState = function(subject) {
      var state;
      state = {
        input: this.parseInput(subject),
        startingPosition: 1,
        currentPosition: 1,
        tokens: [],
        captures: []
      };
      return state;
    };

    Matcher.parseInput = function(inputString) {
      var input;
      input = [StartGuard].concat(inputString.split(""));
      input.push(EndGuard);
      return input;
    };

    Matcher.prototype.stepForward = function() {
      var result;
      result = this.regex.nextMatch(this.state);
      switch (result.type) {
        case Failure:
          this.state.currentPosition = ++this.state.startingPosition;
          this.regex.reset(this.state);
          return this.state.startingPosition < this.state.input.length;
        case Indeterminate:
          return true;
        case Success:
          this.success = true;
          return false;
      }
    };

    Matcher.prototype.group = function(n) {
      if (n == null) {
        n = 0;
      }
      return this.state.captures[n];
    };

    Matcher.prototype.groups = function() {
      return this.state.captures;
    };

    return Matcher;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Regex = (function() {

    function Regex(regexString, report) {
      var _ref;
      if (report == null) {
        report = false;
      }
      if (report) {
        console.log("Regex string:", regexString);
      }
      _ref = Parser.parsePattern(regexString), this.regex = _ref[0], this.nGroups = _ref[1];
      if (report) {
        console.log("Regex pattern:", this.regex);
      }
    }

    Regex.prototype.test = function(inputString) {
      var matcher;
      matcher = this.getMatcher(inputString);
      while (matcher.stepForward()) {
        continue;
      }
      return matcher.success;
    };

    Regex.prototype.match = function(inputString) {
      var matcher;
      matcher = this.getMatcher(inputString);
      while (matcher.stepForward()) {
        continue;
      }
      if (matcher.success) {
        return matcher.groups();
      } else {
        return null;
      }
    };

    Regex.prototype.getMatcher = function(inputString) {
      return new Matcher(this.regex, this.nGroups, inputString);
    };

    Regex.prototype.parseInput = function(inputString) {
      var input;
      input = [StartGuard].concat(inputString.split(""));
      input.push(EndGuard);
      return input;
    };

    Regex.prototype.setupInitialState = function(str, maxGroup) {
      var i, state, _i;
      if (maxGroup == null) {
        maxGroup = 0;
      }
      state = {
        inputString: str,
        input: this.parseInput(str),
        startingPosition: 1,
        currentPosition: 1,
        captures: [],
        report: function() {
          return console.log("Current match: " + this.inputString.slice(this.startingPosition - 1, this.currentPosition - 1));
        }
      };
      for (i = _i = 0; 0 <= maxGroup ? _i <= maxGroup : _i >= maxGroup; i = 0 <= maxGroup ? ++_i : --_i) {
        state.captures[i] = void 0;
      }
      return state;
    };

    return Regex;

  })();

}).call(this);
