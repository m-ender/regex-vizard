// Generated by CoffeeScript 1.4.0
(function() {
  var root,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Helper = (function() {

    function Helper() {}

    Helper.clone = function(obj) {
      var key, newInstance;
      if (!(obj != null) || typeof obj !== 'object') {
        return obj;
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = this.clone(obj[key]);
      }
      return newInstance;
    };

    Helper.extend = function() {
      var key, object, sources, target, val, _i, _len;
      target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        object = sources[_i];
        for (key in object) {
          val = object[key];
          target[key] = val;
        }
      }
      return target;
    };

    return Helper;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.StartGuard = {};

  root.EndGuard = {};

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Token = (function() {

    function Token(debug, token) {
      this.debug = debug;
      this.subtokens = [];
      if (token && token instanceof Token) {
        this.subtokens.push(token);
      }
    }

    Token.prototype.reset = function(state) {
      var subtoken, _i, _len, _ref, _results;
      _ref = this.subtokens;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        _results.push(subtoken.reset(state));
      }
      return _results;
    };

    Token.prototype.register = function(state) {
      var subtoken, _i, _len, _ref;
      _ref = this.subtokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        subtoken.register(state);
      }
      return state.tokens[this.debug.id] = this.setupStateObject(state);
    };

    Token.prototype.setupStateObject = function() {
      return {};
    };

    Token.prototype.nextMatch = function(state) {
      return false;
    };

    return Token;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.StartAnchor = (function(_super) {

    __extends(StartAnchor, _super);

    function StartAnchor(debug) {
      StartAnchor.__super__.constructor.apply(this, arguments);
    }

    StartAnchor.prototype.reset = function(state) {
      StartAnchor.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    StartAnchor.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    StartAnchor.prototype.nextMatch = function(state) {
      var tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      if (state.input[state.currentPosition - 1] === StartGuard) {
        tokenState.attempted = true;
        return state.currentPosition;
      }
      return false;
    };

    return StartAnchor;

  })(root.Token);

  root.EndAnchor = (function(_super) {

    __extends(EndAnchor, _super);

    function EndAnchor(debug) {
      EndAnchor.__super__.constructor.apply(this, arguments);
    }

    EndAnchor.prototype.reset = function(state) {
      EndAnchor.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    EndAnchor.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    EndAnchor.prototype.nextMatch = function(state) {
      var tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      if (state.input[state.currentPosition] === EndGuard) {
        tokenState.attempted = true;
        return state.currentPosition;
      }
      return false;
    };

    return EndAnchor;

  })(root.Token);

  root.WordBoundary = (function(_super) {

    __extends(WordBoundary, _super);

    function WordBoundary(debug, negated) {
      this.negated = negated != null ? negated : false;
      WordBoundary.__super__.constructor.call(this, debug);
      this.wordClass = new WordClass();
    }

    WordBoundary.prototype.reset = function(state) {
      WordBoundary.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    WordBoundary.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    WordBoundary.prototype.nextMatch = function(state) {
      var leftChar, rightChar, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      leftChar = state.input[state.currentPosition - 1];
      rightChar = state.input[state.currentPosition];
      if ((this.wordClass.isInClass(leftChar) !== this.wordClass.isInClass(rightChar)) !== this.negated) {
        tokenState.attempted = true;
        return state.currentPosition;
      }
      return false;
    };

    return WordBoundary;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Character = (function(_super) {

    __extends(Character, _super);

    function Character(debug, character) {
      this.character = character;
      Character.__super__.constructor.call(this, debug);
    }

    Character.prototype.reset = function(state) {
      Character.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    Character.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    Character.prototype.nextMatch = function(state) {
      var tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      if (state.input[state.currentPosition] === this.character) {
        tokenState.attempted = true;
        return state.currentPosition + 1;
      }
      return false;
    };

    return Character;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.CharacterClass = (function(_super) {

    __extends(CharacterClass, _super);

    function CharacterClass(debug, negated, elements) {
      this.negated = negated != null ? negated : false;
      this.elements = elements != null ? elements : [];
      CharacterClass.__super__.constructor.call(this, debug);
    }

    CharacterClass.prototype.reset = function(state) {
      CharacterClass.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    CharacterClass.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    CharacterClass.prototype.register = function(state) {
      return state.tokens[this.debug.id] = this.setupStateObject();
    };

    CharacterClass.prototype.addCharacter = function(character) {
      return this.elements.push(character);
    };

    CharacterClass.prototype.addRange = function(startCharacter, endCharacter) {
      return this.elements.push({
        start: startCharacter.charCodeAt(0),
        end: endCharacter.charCodeAt(0)
      });
    };

    CharacterClass.prototype.nextMatch = function(state) {
      var char, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      char = state.input[state.currentPosition];
      if (this.isInClass(char)) {
        tokenState.attempted = true;
        return state.currentPosition + 1;
      }
      return false;
    };

    CharacterClass.prototype.isInClass = function(char) {
      var element, inSet, _i, _len, _ref, _ref1;
      if (char === StartGuard || char === EndGuard) {
        return false;
      }
      inSet = false;
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        if (typeof element === "string" && char === element || element instanceof CharacterClass && element.isInClass(char) || (element.start <= (_ref1 = char.charCodeAt(0)) && _ref1 <= element.end)) {
          inSet = true;
          break;
        }
      }
      return inSet !== this.negated;
    };

    return CharacterClass;

  })(root.Token);

  root.DigitClass = (function(_super) {

    __extends(DigitClass, _super);

    function DigitClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      DigitClass.__super__.constructor.call(this, debug, negated, [
        {
          start: "0".charCodeAt(0),
          end: "9".charCodeAt(0)
        }
      ]);
    }

    return DigitClass;

  })(root.CharacterClass);

  root.WordClass = (function(_super) {

    __extends(WordClass, _super);

    function WordClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WordClass.__super__.constructor.call(this, debug, negated, [
        {
          start: "A".charCodeAt(0),
          end: "Z".charCodeAt(0)
        }, {
          start: "a".charCodeAt(0),
          end: "z".charCodeAt(0)
        }, {
          start: "0".charCodeAt(0),
          end: "9".charCodeAt(0)
        }, "_"
      ]);
    }

    return WordClass;

  })(root.CharacterClass);

  root.WhitespaceClass = (function(_super) {

    __extends(WhitespaceClass, _super);

    function WhitespaceClass(debug, negated) {
      if (negated == null) {
        negated = false;
      }
      WhitespaceClass.__super__.constructor.call(this, debug, negated, [
        {
          start: 0x9,
          end: 0xd
        }, "\u0020", "\u00a0", "\u1680", "\u180e", {
          start: 0x2000,
          end: 0x200a
        }, "\u2028", "\u2029", "\u202f", "\u205f", "\u3000", "\ufeff"
      ]);
    }

    return WhitespaceClass;

  })(root.CharacterClass);

  root.Wildcard = (function(_super) {

    __extends(Wildcard, _super);

    function Wildcard(debug) {
      Wildcard.__super__.constructor.apply(this, arguments);
    }

    Wildcard.prototype.reset = function(state) {
      Wildcard.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].attempted = false;
    };

    Wildcard.prototype.setupStateObject = function() {
      return {
        attempted: false
      };
    };

    Wildcard.prototype.nextMatch = function(state) {
      var tokenState, _ref;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.attempted) {
        this.reset(state);
        return false;
      }
      if ((_ref = state.input[state.currentPosition]) !== "\n" && _ref !== "\r" && _ref !== "\u2028" && _ref !== "\u2029" && _ref !== EndGuard) {
        tokenState.attempted = true;
        return state.currentPosition + 1;
      }
      return false;
    };

    return Wildcard;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Disjunction = (function(_super) {

    __extends(Disjunction, _super);

    function Disjunction(debug, token) {
      Disjunction.__super__.constructor.apply(this, arguments);
    }

    Disjunction.prototype.reset = function(state) {
      Disjunction.__super__.reset.apply(this, arguments);
      return state.tokens[this.debug.id].i = 0;
    };

    Disjunction.prototype.setupStateObject = function() {
      return {
        i: 0
      };
    };

    Disjunction.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.i === this.subtokens.length) {
        this.reset(state);
        return false;
      }
      result = this.subtokens[tokenState.i].nextMatch(state);
      if (result !== false) {
        return result;
      } else {
        ++tokenState.i;
        return 0;
      }
    };

    return Disjunction;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Group = (function(_super) {

    __extends(Group, _super);

    function Group(debug, token, index) {
      this.index = index;
      Group.__super__.constructor.call(this, debug, token);
    }

    Group.prototype.reset = function(state) {
      Group.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].result = 0;
      return state.tokens[this.debug.id].firstPosition = false;
    };

    Group.prototype.setupStateObject = function() {
      return {
        result: 0,
        firstPosition: false
      };
    };

    Group.prototype.register = function(state) {
      state.captures[this.index] = void 0;
      return Group.__super__.register.apply(this, arguments);
    };

    Group.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.result !== 0) {
        result = tokenState.result;
        if (result === false) {
          this.reset(state);
        } else {
          tokenState.result = 0;
        }
        return result;
      }
      if (tokenState.firstPosition === false) {
        tokenState.firstPosition = state.currentPosition;
      }
      result = this.subtokens[0].nextMatch(state);
      switch (result) {
        case 0:
        case -1:
          return result;
        case false:
          tokenState.result = false;
          state.captures[this.index] = void 0;
          return 0;
        default:
          state.captures[this.index] = state.input.slice(tokenState.firstPosition, result).join("");
          tokenState.result = result;
          return -1;
      }
    };

    return Group;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Quantifier = (function(_super) {

    __extends(Quantifier, _super);

    function Quantifier(debug, token, min, max) {
      this.min = min;
      this.max = max;
      Quantifier.__super__.constructor.call(this, debug, token);
      this.minGroup = -1;
      this.nGroups = 0;
      this.clearer = [];
    }

    Quantifier.prototype.reset = function(state) {
      Quantifier.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].freshSubStates = this.collectSubStates(state, this.subtokens[0]);
      state.tokens[this.debug.id].instances = [Helper.clone(state.tokens[this.debug.id].freshSubStates)];
      state.tokens[this.debug.id].pos = [];
      state.tokens[this.debug.id].result = false;
      return state.tokens[this.debug.id].captureStack = [];
    };

    Quantifier.prototype.setupStateObject = function(state) {
      var stateObject;
      stateObject = {
        freshSubStates: this.collectSubStates(state, this.subtokens[0]),
        instances: [],
        pos: [],
        result: false,
        captureStack: []
      };
      stateObject.instances.push(Helper.clone(stateObject.freshSubStates));
      return stateObject;
    };

    Quantifier.prototype.collectSubStates = function(state, token) {
      var key, states, subtoken, val, _i, _len, _ref, _ref1;
      states = [];
      key = token.debug.id;
      states[key] = state.tokens[key];
      _ref = token.subtokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subtoken = _ref[_i];
        _ref1 = this.collectSubStates(state, subtoken);
        for (key in _ref1) {
          val = _ref1[key];
          states[key] = val;
        }
      }
      return states;
    };

    Quantifier.prototype.restoreSubStates = function(state, subStates) {
      var key, val, _results;
      _results = [];
      for (key in subStates) {
        val = subStates[key];
        _results.push(state.tokens[key] = val);
      }
      return _results;
    };

    Quantifier.prototype.setGroupRange = function(minGroup, nGroups) {
      var i, _i, _ref, _results;
      this.minGroup = minGroup;
      this.nGroups = nGroups;
      _results = [];
      for (i = _i = 0, _ref = this.nGroups; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.clearer[i] = void 0);
      }
      return _results;
    };

    Quantifier.prototype.nextMatch = function(state) {
      var result, token, tokenState, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.result) {
        result = tokenState.result;
        tokenState.result = false;
        if (tokenState.instances.length >= this.min) {
          return result;
        } else {
          return 0;
        }
      }
      if (tokenState.instances.length === 0) {
        this.reset(state);
        return false;
      }
      if (tokenState.instances.length > this.max) {
        tokenState.instances.pop();
        result = state.currentPosition;
        if (tokenState.pos.length > 0) {
          state.currentPosition = tokenState.pos.pop();
        }
        if (tokenState.captureStack.length > 0) {
          [].splice.apply(state.captures, [(_ref = this.minGroup), (this.minGroup + this.nGroups) - _ref].concat(_ref1 = tokenState.captureStack.pop())), _ref1;
        }
        return result;
      }
      token = this.subtokens[0];
      this.restoreSubStates(state, tokenState.instances.pop());
      result = token.nextMatch(state);
      switch (result) {
        case 0:
        case -1:
          tokenState.instances.push(this.collectSubStates(state, token));
          return result;
        case false:
          tokenState.result = state.currentPosition;
          if (tokenState.pos.length > 0) {
            state.currentPosition = tokenState.pos.pop();
          }
          if (tokenState.captureStack.length > 0) {
            [].splice.apply(state.captures, [(_ref2 = this.minGroup), (this.minGroup + this.nGroups) - _ref2].concat(_ref3 = tokenState.captureStack.pop())), _ref3;
          }
          return 0;
        default:
          tokenState.instances.push(this.collectSubStates(state, token));
          if (result === state.currentPosition && tokenState.instances.length > this.min) {
            return this.nextMatch(state);
          }
          tokenState.captureStack.push(state.captures.slice(this.minGroup, this.minGroup + this.nGroups));
          [].splice.apply(state.captures, [(_ref4 = this.minGroup), (this.minGroup + this.nGroups) - _ref4].concat(_ref5 = this.clearer)), _ref5;
          tokenState.instances.push(Helper.clone(tokenState.freshSubStates));
          tokenState.pos.push(state.currentPosition);
          state.currentPosition = result;
          return -1;
      }
    };

    return Quantifier;

  })(root.Token);

  root.Option = (function(_super) {

    __extends(Option, _super);

    function Option(debug, token) {
      Option.__super__.constructor.call(this, debug, token, 0, 1);
    }

    return Option;

  })(root.Quantifier);

  root.RepeatZeroOrMore = (function(_super) {

    __extends(RepeatZeroOrMore, _super);

    function RepeatZeroOrMore(debug, token) {
      RepeatZeroOrMore.__super__.constructor.call(this, debug, token, 0, Infinity);
    }

    return RepeatZeroOrMore;

  })(root.Quantifier);

  root.RepeatOneOrMore = (function(_super) {

    __extends(RepeatOneOrMore, _super);

    function RepeatOneOrMore(debug, token) {
      RepeatOneOrMore.__super__.constructor.call(this, debug, token, 1, Infinity);
    }

    return RepeatOneOrMore;

  })(root.Quantifier);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Sequence = (function(_super) {

    __extends(Sequence, _super);

    function Sequence(debug) {
      Sequence.__super__.constructor.call(this, debug);
    }

    Sequence.prototype.reset = function(state) {
      Sequence.__super__.reset.apply(this, arguments);
      state.tokens[this.debug.id].i = 0;
      return state.tokens[this.debug.id].pos = [];
    };

    Sequence.prototype.setupStateObject = function() {
      return {
        i: 0,
        pos: []
      };
    };

    Sequence.prototype.nextMatch = function(state) {
      var result, tokenState;
      tokenState = state.tokens[this.debug.id];
      if (tokenState.i === -1) {
        this.reset(state);
        return false;
      }
      if (this.subtokens.length === 0) {
        --tokenState.i;
        return state.currentPosition;
      }
      result = this.subtokens[tokenState.i].nextMatch(state);
      switch (result) {
        case false:
          --tokenState.i;
          if (tokenState.pos.length > 0) {
            state.currentPosition = tokenState.pos.pop();
          }
          return 0;
        case -1:
        case 0:
          return result;
        default:
          if (tokenState.i === this.subtokens.length - 1) {
            return result;
          } else {
            ++tokenState.i;
            tokenState.pos.push(state.currentPosition);
            state.currentPosition = result;
            return -1;
          }
      }
    };

    return Sequence;

  })(root.Token);

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Parser = (function() {

    function Parser() {}

    Parser.parsePattern = function(string) {
      var char, current, debug, element, fillGroupRanges, group, i, lastCaptureIndex, lastId, nGroups, nestingStack, squash, start, treeRoot, _, _ref, _ref1;
      lastId = -1;
      treeRoot = new Group({
        sourceOpenLength: 0,
        sourceCloseLength: 0,
        id: ++lastId
      }, new Disjunction({
        id: ++lastId
      }, new Sequence({
        id: ++lastId
      })), 0);
      nestingStack = [];
      current = treeRoot.subtokens[0];
      i = 0;
      lastCaptureIndex = 0;
      while (i < string.length) {
        char = string.charAt(i);
        switch (char) {
          case "\\":
            start = i;
            _ref = this.parseEscapeSequence(false, string, i + 1), i = _ref[0], element = _ref[1];
            element.debug = {
              sourceLength: i - start,
              id: ++lastId
            };
            this.append(current, element);
            break;
          case "[":
            i = this.parseCharacterClass(string, current, i + 1, ++lastId);
            break;
          case "^":
            debug = {
              sourceLength: 1,
              id: ++lastId
            };
            this.append(current, new StartAnchor(debug));
            ++i;
            break;
          case "$":
            debug = {
              sourceLength: 1,
              id: ++lastId
            };
            this.append(current, new EndAnchor(debug));
            ++i;
            break;
          case ".":
            debug = {
              sourceLength: 1,
              id: ++lastId
            };
            this.append(current, new Wildcard(debug));
            ++i;
            break;
          case "|":
            current.subtokens.push(new Sequence({
              id: ++lastId
            }));
            ++i;
            break;
          case "(":
            debug = {
              sourceOpenLength: 1,
              sourceCloseLength: 1,
              id: ++lastId
            };
            group = new Group(debug, new Disjunction({
              id: ++lastId
            }, new Sequence({
              id: ++lastId
            })), ++lastCaptureIndex);
            this.append(current, group);
            nestingStack.push(current);
            current = group.subtokens[0];
            ++i;
            break;
          case ")":
            if (nestingStack.length === 0) {
              throw {
                name: "UnmatchedClosingParenthesisException",
                message: "Unmatched closing parenthesis \")\" at index " + i,
                index: i
              };
            }
            current = nestingStack.pop();
            ++i;
            break;
          case "?":
          case "*":
          case "+":
            i = this.parseQuantifier(current, char, i, ++lastId);
            break;
          default:
            debug = {
              sourceLength: 1,
              id: ++lastId
            };
            this.append(current, new Character(debug, char));
            ++i;
        }
      }
      if (nestingStack.length !== 0) {
        throw {
          name: "MissingClosingParenthesisException",
          message: "Missing closing parenthesis \")\""
        };
      }
      squash = function(token) {
        var subtoken, _i, _ref1, _results;
        if (token.subtokens.length === 0) {
          return;
        }
        _results = [];
        for (i = _i = 0, _ref1 = token.subtokens.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          subtoken = token.subtokens[i];
          while (((subtoken instanceof Disjunction) || (subtoken instanceof Sequence)) && (subtoken.subtokens.length === 1)) {
            token.subtokens[i] = subtoken.subtokens[0];
            subtoken = token.subtokens[i];
          }
          _results.push(squash(subtoken));
        }
        return _results;
      };
      squash(treeRoot);
      fillGroupRanges = function(token) {
        var max, min, subMax, subMin, subtoken, _i, _len, _ref1, _ref2;
        if (token instanceof Group) {
          min = token.index;
          max = token.index;
        } else {
          min = Infinity;
          max = -Infinity;
        }
        if (token.subtokens.length > 0) {
          _ref1 = token.subtokens;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            subtoken = _ref1[_i];
            _ref2 = fillGroupRanges(subtoken), subMin = _ref2[0], subMax = _ref2[1];
            min = Math.min(min, subMin);
            max = Math.max(max, subMax);
          }
        }
        if (token instanceof Quantifier && min < Infinity && max > -Infinity) {
          token.setGroupRange(min, max - min + 1);
        }
        return [min, max];
      };
      _ref1 = fillGroupRanges(treeRoot), _ = _ref1[0], nGroups = _ref1[1];
      return [treeRoot, nGroups];
    };

    Parser.parseCharacterClass = function(string, current, i, id) {
      var char, debug, element, elements, endC, lastElement, negated, newI, nextElement, startC, _ref, _ref1;
      if (i < string.length && string.charAt(i) === "^") {
        negated = true;
        ++i;
      } else {
        negated = false;
      }
      elements = [];
      while (i < string.length) {
        char = string.charAt(i);
        switch (char) {
          case "]":
            debug = {
              sourceOpenLength: negated ? 2 : 1,
              sourceCloseLength: 1,
              id: id
            };
            this.append(current, new CharacterClass(debug, negated, elements));
            return i + 1;
          case "\\":
            _ref = this.parseEscapeSequence(true, string, i + 1), i = _ref[0], element = _ref[1];
            elements.push(element);
            break;
          case "-":
            lastElement = elements[elements.length - 1];
            if (lastElement instanceof CharacterClass) {
              throw {
                name: "CharacterClassInRangeException",
                message: "Built-in character classes cannot be used in ranges"
              };
            }
            if (typeof lastElement === "string" && i + 1 < string.length && (nextElement = string.charAt(i + 1)) !== "]") {
              newI = i + 2;
              if (nextElement === "\\") {
                _ref1 = this.parseEscapeSequence(true, string, i + 2), newI = _ref1[0], nextElement = _ref1[1];
              }
              if (nextElement instanceof CharacterClass) {
                throw {
                  name: "CharacterClassInRangeException",
                  message: "Built-in character classes cannot be used in ranges"
                };
              }
              startC = lastElement.charCodeAt(0);
              endC = nextElement.charCodeAt(0);
              if (startC > endC) {
                throw {
                  name: "CharacterClassRangeOutOfOrderException",
                  message: "The character class \"" + lastElement + "\" to \"" + nextElement + "\" is out of order."
                };
              }
              elements.pop();
              elements.push({
                start: startC,
                end: endC
              });
              i = newI;
            } else {
              elements.push(char);
              ++i;
            }
            break;
          default:
            elements.push(char);
            ++i;
        }
      }
      throw {
        name: "UnterminatedCharacterClassException",
        message: "Missing closing bracket \"]\"",
        index: i
      };
    };

    Parser.parseEscapeSequence = function(inCharacterClass, string, i) {
      var char, element, negated;
      if (i === string.length) {
        throw {
          name: "NothingToEscapeException",
          message: "There is nothing to escape. Most likely, the pattern ends in a backslash \"\\\"",
          index: i - 1
        };
      }
      char = string.charAt(i);
      switch (char) {
        case "0":
          element = "\0";
          break;
        case "f":
          element = "\f";
          break;
        case "n":
          element = "\n";
          break;
        case "r":
          element = "\r";
          break;
        case "t":
          element = "\t";
          break;
        case "v":
          element = "\v";
          break;
        case "d":
        case "D":
          negated = char === "D";
          element = new DigitClass(null, negated);
          break;
        case "w":
        case "W":
          negated = char === "W";
          element = new WordClass(null, negated);
          break;
        case "s":
        case "S":
          negated = char === "S";
          element = new WhitespaceClass(null, negated);
          break;
        case "b":
          element = inCharacterClass ? "\b" : new WordBoundary(null, false);
          break;
        case "B":
          element = inCharacterClass ? "B" : new WordBoundary(null, true);
          break;
        default:
          element = char;
      }
      if (typeof element === "string" && !inCharacterClass) {
        element = new Character(null, element);
      }
      return [i + 1, element];
    };

    Parser.parseQuantifier = function(current, char, i, id) {
      var debug, quantifierClass, st, target;
      st = current.subtokens;
      if (st[st.length - 1].subtokens.length === 0) {
        throw {
          name: "NothingToRepeatException",
          message: "The is nothing to repeat for quantifier \"" + char + "\" at index " + i,
          index: i
        };
      }
      target = this.remove(current);
      if (!((target instanceof Group) || (target instanceof Character) || (target instanceof Wildcard) || (target instanceof CharacterClass))) {
        throw {
          name: "NothingToRepeatException",
          message: "The is nothing to repeat for quantifier \"" + char + "\" at index " + i + ". Only groups, characters and wildcard may be quantified.",
          index: i
        };
      }
      debug = {
        sourceLength: 1,
        id: id
      };
      quantifierClass = {
        "*": RepeatZeroOrMore,
        "+": RepeatOneOrMore,
        "?": Option
      };
      this.append(current, new quantifierClass[char](debug, target));
      return i + 1;
    };

    Parser.append = function(current, token) {
      var st;
      st = current.subtokens;
      return st[st.length - 1].subtokens.push(token);
    };

    Parser.remove = function(current) {
      var st;
      st = current.subtokens;
      return st[st.length - 1].subtokens.pop();
    };

    return Parser;

  })();

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Regex = (function() {

    function Regex(regexString, report) {
      var _ref;
      if (report == null) {
        report = false;
      }
      if (report) {
        console.log("Regex string:", regexString);
      }
      _ref = Parser.parsePattern(regexString), this.regex = _ref[0], this.nGroups = _ref[1];
      if (report) {
        console.log("Regex pattern:", this.regex);
      }
    }

    Regex.prototype.test = function(inputString) {
      var matcher;
      matcher = this.getMatcher(inputString);
      while (matcher.stepForward()) {
        continue;
      }
      return matcher.success;
    };

    Regex.prototype.match = function(inputString) {
      var matcher;
      matcher = this.getMatcher(inputString);
      while (matcher.stepForward()) {
        continue;
      }
      if (matcher.success) {
        return matcher.groups();
      } else {
        return null;
      }
    };

    Regex.prototype.getMatcher = function(inputString) {
      return new Matcher(this.regex, this.nGroups, inputString);
    };

    Regex.prototype.parseInput = function(inputString) {
      var input;
      input = [StartGuard].concat(inputString.split(""));
      input.push(EndGuard);
      return input;
    };

    Regex.prototype.setupInitialState = function(str, maxGroup) {
      var i, state, _i;
      if (maxGroup == null) {
        maxGroup = 0;
      }
      state = {
        inputString: str,
        input: this.parseInput(str),
        startingPosition: 1,
        currentPosition: 1,
        captures: [],
        report: function() {
          return console.log("Current match: " + this.inputString.slice(this.startingPosition - 1, this.currentPosition - 1));
        }
      };
      for (i = _i = 0; 0 <= maxGroup ? _i <= maxGroup : _i >= maxGroup; i = 0 <= maxGroup ? ++_i : --_i) {
        state.captures[i] = void 0;
      }
      return state;
    };

    return Regex;

  })();

}).call(this);
